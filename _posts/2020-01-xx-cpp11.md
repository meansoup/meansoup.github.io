---
layout: post
title: C++11
tag:
  - c++
---

요새 modern cpp를 공부한다고 cpp11과 cpp14를 공부하고 있다.  
뭐가 이렇게 새로운게 많은 것인가.. 싶다.  
이런것도 모르고 cpp를 쓰고 있었다니 그런데 한 숨에 이해하기 어려운 것들도 있는데, 나름대로 이해해서 적어 보았다.  
많은 C++ 개발자들이 C를 배우기도 했고, 최신 C++의 기능들을 적용하지 못하고 있다는게 이런 코드들이 (우리회사에서도) 잘 사용되지 않는 이유인 듯 했다.  

[C++11 wiki](https://en.wikipedia.org/wiki/C%2B%2B11) 참고하였다.  

## Table of Contents:
- [Table of Contents:](#table-of-contents)
- [Lvalue, Rvalue](#lvalue-rvalue)
- [extern template](#extern-template)
- [Uniform Initialization](#uniform-initialization)
  - [Member Initializer List](#member-initializer-list)
- [Type Inference](#type-inference)
- [Range-based for loop](#range-based-for-loop)
- [std::array](#stdarray)

-----

## Lvalue, Rvalue
[MS Docs. Rvalue Reference](https://docs.microsoft.com/ko-kr/cpp/cpp/rvalue-reference-declarator-amp-amp?view=vs-2019) 참고.  
- lvalue: left value이자, locator value.  
Rvalue reference를 통해, 기존에 발생할 수 있는 문제들을 해결하고, move constructor의 기반으로 사용.
```cpp
int& lv = 1;    // error Lvalue 참조
int&& rv = 1;   //       Rvalue 참조
```

## extern template
`extern template class std::vector<MyClass>`과 같이 template에 extern을 사용할 수 있게 되었음.

## Uniform Initialization
C++11에서 uniform initialization을 도입하여, 초기화 구문의 혼동을 완화하고, 어디서나 사용할 수 있는 초기화 구문을 도입함.  
다른 초기화 방식(`()`, `=`)에서 제대로 초기화되지 않는 부분들도 잘 초기화될 수 있음.  
특히 서로 다른 값을 담는 STL 컨테이너를 직접 생성 후 값들을 추가했어야 하는 부분들이 쉽게 초기화 할 수 있게 되었음.  
```cpp
class widget {
    private:
        int x{0};   // ok
        int y = 0;  // ok
        int z(0);   // error
}

std::atomic<int>a1{0};      // ok
std::atomic<int>a2(0);      // ok
std::atomic<int>a3 = 0;     // error

double x, y;
int sum{x + y};     // error. double can't be int. sum(x+ y) can do it.

// C++98
Person p1{20, "Tom"};
Person p2{19, "Jane"};

// C++11
vector<Person> vec{{21, "Smith"}, {23, "Mary"}};
```

### Member Initializer List
생성자가 길어지는 것을 줄일 수 있고, 효율적으로 초기화시킬 수 있음.  
```cpp
// C++98
Point(int ax, int ay) { x = ax, y = ay;}

// C++11
Point(int ax, int ay) : x(ax), y(ay) {/* more if need */}
```
* cpp는 `int n(3);`과 같은 초기화가 가능하기 때문.
* `x(ax)`대신 `x{ax}`도 가능.
* 기존 대입식 초기화는 객체를 위한 메모리 생성/할당 후 여기에 값을 넣고 이 값을 멤버변수에 대입.
* 반면 초기화 리스트는 객체의 생성과 초기화를 한번에 하기 때문에 오버헤드를 줄일 수 있음.
* 반드시 초기화 리스트가 필요한 경우 (== 대입식 초기화로 안되는 경우)
1. 클래스가 레퍼런스를 멤버변수로 갖는 경우
2. 클래스가 non static + const 멤버 변수를 갖는 경우
3. 자식 클래스가 부모 클래스의 private 변수를 초기화하는 경우
4. 자식 클래스가 부모 클래스를 초기화하는 경우
  - ex, `child(int ai, int aj, int ak): parent(ai, aj), k(ak)`

## Type Inference
C++11에서 `auto`와 `decltype`키워드가 추가되었다.  

`auto` 키워드.  
1. `auto` 타입을 통해 파이썬처럼 자료형을 명시하지 않고 사용할 수 있게 되었음.
2. `auto` 타입은 항상 초기화를 필요로 하기 때문에, 코드에따라 초기화가 되지 않을 수 있어 발생하던 문제들을 보완할 수 있는 역할을 함.
3. 이식(다른 bit의 프로그램)성 문제에서 형식 불일치가 발생하는 경우가 없어짐.
4. 예를 들면 `std::function`객체를 사용하면 `auto`를 사용하는 것보다 일반적으로 메모리를 많이 사용하고 속도도 느림.
   - `auto`는 클로저를 담는 변수와 클로저와 같은 형식. `std::function`은 `std::function` 템플릿의 한 인스턴스 크기이고, 고정되어 있음. 클로저를 저장하기에 부족한 경우, 힙 메모리를 할당해서 클로저를 저장함.
5. 코드의 길이도 더 짧아짐.

`decltype` 키워드.  
decltype은 컴파일러가 type을 결정하도록 하는 것. type을 알려주는 것.  
auto 키워드가 method의 return type으로 쓰일 때, return type을 알지 못하면 error가 발생함.
- 그러면 후행 반환 형식으로 type을 명시하거나, decltype을 사용해야 함.

## Range-based for loop
java에서처럼 `:`을 통한 for문을 사용할 수 있다. `for (int i: arr)`  
array에서 배열의 길이를 지정해주지 않아도 되며, i의 초기값을 정해주지 않아도 된다.  
또한, 언제까지 순회할지를 지정하지 않아도 된다.  
- 이건 내가 원하는데까지 순회할 수 없다는 단점도 됨.

응용:  
* 복사 방지: `for (auto &i:arr)`
* 변경 방지: `for (auto const i:arr)`

## std::array
vector에서 지원하는 함수들을 유사하게 지원하면서, array를 만들어서 구현할 수 있또록 함.
array[]와의 차이:  
1. std::array는 객체이기 때문에 크기를 알 수 있음. `arr.size()`
2. std::array는 index가 비어있어도 됨.
3. std::array는 생성시 크기를 명시해야 함.
4. std::array는 대입이 가능함.

[Cpp Reference](https://en.cppreference.com/w/cpp/container/array) 참고.
- 단순히 C의 array[]를 가지고 있는 집합체로, C의 array와 동일한 성능을 내면서 size를 얻거나, 할당 지원과 같은 장점을 얻을 수 있음.

